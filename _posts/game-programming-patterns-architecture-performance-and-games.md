## 架构、性能、游戏
    http://gameprogrammingpatterns.com/architecture-performance-and-games.html
    在我们开始深入一些模式之前，我想给出一些我自己对于软件架构和怎样把架构应用到游戏，这些可能对你会有所帮助。可以帮助你更好地理解本书剩余章节。如果不出意外的话，当你被卷入一场关于设计模式和软件架构有多糟糕（棒）的时候可以多一些谈资。
    ## 软件架构是什么
    如果你从头到尾阅读本书，你将不可避免的要有些知识储备，比如3D图形学中的线性代数，游戏物理中的微积分知识。本书也不会教你怎么用alpha-beta精简你的AI查找树或者在声音播放时模拟房间回响效果。
    反之，本书要说明的是他们之间的那些所有代码。更多的是关于如何组织代码，如何编写这些代码相对来说是次要的。每个程序都有一些组织结构，即使是“把所有代码都放在main()函数，然后坐观其变”，因此我想探讨一下如何更好的组织代码更是一件有趣的事情。我们怎么区分一个好的架构和坏的架构呢？
    我已经仔细思考这个问题差不多五年了，当然，如果你的话，你可能觉得对好的架构设计有一种直觉。我们都饱受差的基础代码折磨，你能为它所做的最大希望是把它们拿出来，然后把它们从水火之中解救出来。
    一些运气好的人可能不会有这样的痛苦精力，有机会工作在优美的架构设计代码之中。这样的好代码就像是在幻想中预定的被热情接待员接待的完美奢华酒店。你觉得它们之间的差别是什么？
    ##好的软件架构
    对我来说，好的设计意味着当改变代码时，整个程序依然浑然一体。我只需要调用一些功能函数，对于整个代码结构没有丝毫影响。
    听起来很美好，但是执行起来可能是另一回事。对，“只写对整体影响很小的代码”。
    让我们开始整理一下思路。第一个关键点是架构是为了修改。有些人需要修改基础代码。如果没有人修改代码，是因为代码已经很完美、完整了，还是因为代码设计太烂了，没有人愿意因为它而玷污了自己的代码编辑器。衡量一个架构设计的好坏是架构适应修改的难易程度。没有修改，就像是参赛者没有离开起跑线一样。
    ##怎么对代码进行一次修改
    在你修改代码增加一个新的功能时，或是为了修复一个Bug，或是因为其它什么原因促使你打开了自己的代码编辑器，你不得不了解已有代码的功能。当然，你不必去了解整个程序，但是，你需要查看所有相关的代码。
    We tend to gloss over this step, but it’s often the most time-consuming part of programming. If you think paging some data from disk into RAM is slow, try paging it into a simian cerebrum over a pair of optical nerves.